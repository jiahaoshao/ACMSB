这个C程序演示了使用`fork()`函数创建两个子进程，并在每个进程中执行一个循环打印特定的字符串，同时使用`lockf()`函数对标准输出进行锁定以避免输出混乱。以下是程序的逐步分析：

1. **变量声明**：变量`p1`、`p2`和`i`被声明。

2. **创建第一个子进程**：
   1. 使用`fork()`创建第一个子进程，并将返回值赋给`p1`。
   2. 如果`fork()`返回`-1`，表示创建子进程失败，程序会继续尝试创建子进程，直到成功。

3. **第一个子进程**：
   1. 如果`p1`为`0`，表示当前是第一个子进程。
   2. 使用`lockf(1,1,0)`锁定标准输出。
   3. 第一个子进程执行一个循环，打印"son"和循环变量`i`的值，共打印50000次。
   4. 使用`lockf(1,0,0)`解锁标准输出。

4. **父进程**：
   1. 如果`p1`不为`0`，表示当前是父进程。
   2. 父进程继续创建第二个子进程，并将返回值赋给`p2`。
   3. 如果`fork()`返回`-1`，表示创建子进程失败，程序会继续尝试创建子进程，直到成功。

5. **第二个子进程**：
   1. 如果`p2`为`0`，表示当前是第二个子进程。
   2. 使用`lockf(1,1,0)`锁定标准输出。
   3. 第二个子进程执行一个循环，打印"daughter"和循环变量`i`的值，共打印50000次。
   4. 使用`lockf(1,0,0)`解锁标准输出。

6. **父进程**：
   1. 如果`p2`不为`0`，表示当前是父进程。
   2. 使用`lockf(1,1,0)`锁定标准输出。
   3. 父进程执行一个循环，打印"parent"和循环变量`i`的值，共打印50000次。
   4. 使用`lockf(1,0,0)`解锁标准输出。

### 预期输出

由于每个进程都会执行一个循环并打印特定的字符串，最终会有三个进程同时运行，输出的顺序和内容会有所不同。以下是可能的输出示例：

```
son0
son1
...
son49999
daughter0
daughter1
...
daughter49999
parent0
parent1
...
parent49999
```

### 输出解释

- **第一个子进程**：
    - 打印"son"和循环变量`i`的值，共打印50000次。

- **第二个子进程**：
    - 打印"daughter"和循环变量`i`的值，共打印50000次。

- **父进程**：
    - 打印"parent"和循环变量`i`的值，共打印50000次。

注意：由于使用了`lockf()`函数对标准输出进行锁定，输出的顺序会按照进程的执行顺序进行，避免了输出混乱。